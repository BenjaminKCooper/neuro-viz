function getBBForVertices(e){var t=new THREE.BufferGeometry;return t.addAttribute("position",new THREE.BufferAttribute(new Float32Array(e),3)),t.computeBoundingBox(),t.boundingBox}function getBSForVertices(e){var t=new THREE.BufferGeometry;return t.addAttribute("position",new THREE.BufferAttribute(new Float32Array(e),3)),t.computeBoundingSphere(),t.boundingSphere}function getNormalsForVertices(e){var t=new THREE.BufferGeometry;return t.addAttribute("position",new THREE.BufferAttribute(new Float32Array(e),3)),t.computeVertexNormals(),ok(void 0!==t.attributes.normal,"normal attribute was created"),t.attributes.normal.array}module("BufferGeometry");var DegToRad=Math.PI/180;test("add / delete Attribute",function(){var e=new THREE.BufferGeometry,t="position";ok(void 0===e.attributes[t],"no attribute defined"),e.addAttribute(t,new THREE.BufferAttribute(new Float32Array([1,2,3],1))),ok(void 0!==e.attributes[t],"attribute is defined"),e.removeAttribute(t),ok(void 0===e.attributes[t],"no attribute defined")}),test("applyMatrix",function(){var e=new THREE.BufferGeometry;e.addAttribute("position",new THREE.BufferAttribute(new Float32Array(6),3));var t=(new THREE.Matrix4).set(1,0,0,1.5,0,1,0,-2,0,0,1,3,0,0,0,1);e.applyMatrix(t);var r=e.attributes.position.array,o=t.elements;ok(r[0]===o[12]&&r[1]===o[13]&&r[2]===o[14],"position was extracted from matrix"),ok(r[3]===o[12]&&r[4]===o[13]&&r[5]===o[14],"position was extracted from matrix twice"),ok(1===e.attributes.position.version,"version was increased during update")}),test("rotateX/Y/Z",function(){var e=new THREE.BufferGeometry;e.addAttribute("position",new THREE.BufferAttribute(new Float32Array([1,2,3,4,5,6]),3));var t=e.attributes.position.array;e.rotateX(180*DegToRad),ok(1===t[0]&&t[1]===-2&&t[2]===-3&&4===t[3]&&t[4]===-5&&t[5]===-6,"vertices were rotated around x by 180 degrees"),e.rotateY(180*DegToRad),ok(t[0]===-1&&t[1]===-2&&3===t[2]&&t[3]===-4&&t[4]===-5&&6===t[5],"vertices were rotated around y by 180 degrees"),e.rotateZ(180*DegToRad),ok(1===t[0]&&2===t[1]&&3===t[2]&&4===t[3]&&5===t[4]&&6===t[5],"vertices were rotated around z by 180 degrees")}),test("translate",function(){var e=new THREE.BufferGeometry;e.addAttribute("position",new THREE.BufferAttribute(new Float32Array([1,2,3,4,5,6]),3));var t=e.attributes.position.array;e.translate(10,20,30),ok(11===t[0]&&22===t[1]&&33===t[2]&&14===t[3]&&25===t[4]&&36===t[5],"vertices were translated")}),test("scale",function(){var e=new THREE.BufferGeometry;e.addAttribute("position",new THREE.BufferAttribute(new Float32Array([-1,-1,-1,2,2,2]),3));var t=e.attributes.position.array;e.scale(1,2,3),ok(t[0]===-1&&t[1]===-2&&t[2]===-3&&2===t[3]&&4===t[4]&&6===t[5],"vertices were scaled")}),test("center",function(){var e=new THREE.BufferGeometry;e.addAttribute("position",new THREE.BufferAttribute(new Float32Array([-1,-1,-1,1,1,1,4,4,4]),3)),e.center();var t=e.attributes.position.array;e.boundingBox;ok(t[0]===-2.5&&t[1]===-2.5&&t[2]===-2.5&&t[3]===-.5&&t[4]===-.5&&t[5]===-.5&&2.5===t[6]&&2.5===t[7]&&2.5===t[8],"vertices were replaced by boundingBox dimensions")}),test("setFromObject",function(){var e=new THREE.Geometry;e.vertices.push(new THREE.Vector3(-10,0,0),new THREE.Vector3(0,10,0),new THREE.Vector3(10,0,0)),e.colors.push(new THREE.Color(1,0,0),new THREE.Color(0,1,0),new THREE.Color(0,0,1));var t=new THREE.Line(e,null),r=(new THREE.BufferGeometry).setFromObject(t),o=r.attributes.position.array,a=r.attributes.color.array,i=e.vertices,n=e.colors;ok(void 0!==o&&3*i.length===o.length&&3===r.attributes.position.count&&o[0]===i[0].x&&o[1]===i[0].y&&o[2]===i[0].z&&o[3]===i[1].x&&o[4]===i[1].y&&o[5]===i[1].z&&o[6]===i[2].x&&o[7]===i[2].y&&o[8]===i[2].z,"positions are equal"),ok(void 0!==a&&3*n.length===a.length&&3===r.attributes.color.count&&a[0]===n[0].r&&a[1]===n[0].g&&a[2]===n[0].b&&a[3]===n[1].r&&a[4]===n[1].g&&a[5]===n[1].b&&a[6]===n[2].r&&a[7]===n[2].g&&a[8]===n[2].b,"colors are equal")}),test("computeBoundingBox",function(){var e=getBBForVertices([-1,-2,-3,13,-2,-3.5,-1,-20,0,-4,5,6]);ok(e.min.x===-4&&e.min.y===-20&&e.min.z===-3.5,"min values are set correctly"),ok(13===e.max.x&&5===e.max.y&&6===e.max.z,"max values are set correctly"),e=getBBForVertices([-1,-1,-1]),ok(e.min.x===e.max.x&&e.min.y===e.max.y&&e.min.z===e.max.z,"since there is only one vertex, max and min are equal"),ok(e.min.x===-1&&e.min.y===-1&&e.min.z===-1,"since there is only one vertex, min and max are this vertex")}),test("computeBoundingSphere",function(){var e=getBSForVertices([-10,0,0,10,0,0]);ok(10===e.radius,"radius is equal to deltaMinMax / 2"),ok(0===e.center.x&&0===e.center.y&&0===e.center.y,"bounding sphere is at ( 0, 0, 0 )");var e=getBSForVertices([-5,11,-3,5,-11,3]),t=new THREE.Vector3(5,11,3).length();ok(e.radius===t,"radius is equal to directionLength"),ok(0===e.center.x&&0===e.center.y&&0===e.center.y,"bounding sphere is at ( 0, 0, 0 )")}),test("computeVertexNormals",function(){var e=getNormalsForVertices([-1,0,0,1,0,0,0,1,0]);ok(0===e[0]&&0===e[1]&&1===e[2],"first normal is pointing to screen since the the triangle was created counter clockwise"),ok(0===e[3]&&0===e[4]&&1===e[5],"second normal is pointing to screen since the the triangle was created counter clockwise"),ok(0===e[6]&&0===e[7]&&1===e[8],"third normal is pointing to screen since the the triangle was created counter clockwise");var e=getNormalsForVertices([1,0,0,-1,0,0,0,1,0]);ok(0===e[0]&&0===e[1]&&e[2]===-1,"first normal is pointing to screen since the the triangle was created clockwise"),ok(0===e[3]&&0===e[4]&&e[5]===-1,"second normal is pointing to screen since the the triangle was created clockwise"),ok(0===e[6]&&0===e[7]&&e[8]===-1,"third normal is pointing to screen since the the triangle was created clockwise");var e=getNormalsForVertices([0,0,1,0,0,-1,1,1,0]),t=new THREE.Vector3(1,1,0).normalize(),r=t.dot(new THREE.Vector3(e[0],e[1],e[2]));ok(r<Number.EPSILON,"normal is equal to reference vector");for(var e=getNormalsForVertices([1,0,0,-1,0,0]),o=0;o<e.length;o++)ok(!e[o],"normals can't be calculated which is good")}),test("merge",function(){var e=new THREE.BufferGeometry;e.addAttribute("attrName",new THREE.BufferAttribute(new Float32Array([1,2,3,0,0,0]),3));var t=new THREE.BufferGeometry;t.addAttribute("attrName",new THREE.BufferAttribute(new Float32Array([4,5,6]),3));var r=e.attributes.attrName.array;e.merge(t,1);for(var o=0;o<r.length;o++)ok(r[o]===o+1,"");e.merge(t),ok(4===r[0]&&5===r[1]&&6===r[2],"copied the 3 attributes without offset")}),test("copy",function(){var e=new THREE.BufferGeometry;e.addAttribute("attrName",new THREE.BufferAttribute(new Float32Array([1,2,3,4,5,6]),3)),e.addAttribute("attrName2",new THREE.BufferAttribute(new Float32Array([0,1,3,5,6]),1));var t=(new THREE.BufferGeometry).copy(e);ok(t!==e&&e.id!==t.id,"new object was created"),Object.keys(e.attributes).forEach(function(r){var o=e.attributes[r];ok(void 0!==o,"all attributes where copied");for(var a=0;a<o.array.length;a++)ok(o.array[a]===t.attributes[r].array[a],"values of the attribute are equal")})});