function checkGeometryClone(e){var t=e.clone();QUnit.assert.notEqual(t.uuid,e.uuid,"clone uuid should differ from original"),QUnit.assert.notEqual(t.id,e.id,"clone id should differ from original");var i=["parameters","widthSegments","heightSegments","depthSegments"],n=getDifferingProp(e,t,i);ok(void 0===n,"properties are equal"),n=getDifferingProp(t,e,i),ok(void 0===n,"properties are equal"),checkGeometryJsonRoundtrip(t)}function getDifferingProp(e,t,i){i=i||[];for(var n=Object.keys(e),r=Object.keys(t),o=void 0,a=0,s=n.length;a<s;a++){var u=n[a];if(!(i.indexOf(u)>=0)&&r.indexOf(u)<0){o=u;break}}return o}function checkGeometryJsonWriting(e,t){QUnit.assert.equal(t.metadata.version,"4.4","check metadata version"),QUnit.assert.equalKey(e,t,"type"),QUnit.assert.equalKey(e,t,"uuid"),QUnit.assert.equal(t.id,void 0,"should not persist id");var i=e.parameters;if(i){for(var n=Object.keys(i),r=0,o=n.length;r<o;r++)QUnit.assert.equalKey(i,t,n[r]);for(var a=["metadata","uuid","type"],n=Object.keys(t),r=0,o=n.length;r<o;r++){var s=n[r];a.indexOf(s)===-1&&QUnit.assert.equalKey(i,t,s)}}}function checkGeometryJsonReading(e,t){var i=[e],n=new THREE.ObjectLoader,r=n.parseGeometries(i);QUnit.assert.ok(r[t.uuid],"geometry matching source uuid not in output");var o=getDifferingProp(r[t.uuid],t,["bones"]);o&&console.log(o);var a=["bones"],s=getDifferingProp(r[t.uuid],t,a);ok(void 0===s,"properties are equal"),s=getDifferingProp(t,r[t.uuid],a),ok(void 0===s,"properties are equal")}function checkGeometryJsonRoundtrip(e){var t=e.toJSON();checkGeometryJsonWriting(e,t),checkGeometryJsonReading(t,e)}function checkFinite(e){for(var t=!0,i=e.vertices||[],n=0,r=i.length;n<r;n++){var o=e.vertices[n];if(!(isFinite(o.x)||isFinite(o.y)||isFinite(o.z))){t=!1;break}}QUnit.assert.ok(t,"contains only finite coordinates")}function runStdGeometryTests(e,t){for(var i=0,n=t.length;i<n;i++){var r=t[i];checkFinite(r),checkGeometryClone(r),checkGeometryJsonRoundtrip(r)}}function runStdLightTests(e,t){for(var i=0,n=t.length;i<n;i++){var r=t[i];checkLightClone(r),checkLightJsonRoundtrip(r)}}function checkLightClone(e){var t=e.clone();QUnit.assert.notEqual(t.uuid,e.uuid,"clone uuid should differ from original"),QUnit.assert.notEqual(t.id,e.id,"clone id should differ from original"),QUnit.assert.smartEqual(t,e,"clone is equal to original"),checkLightJsonRoundtrip(t)}function checkLightJsonWriting(e,t){QUnit.assert.equal(t.metadata.version,"4.4","check metadata version");var i=t.object;QUnit.assert.equalKey(e,i,"type"),QUnit.assert.equalKey(e,i,"uuid"),QUnit.assert.equal(i.id,void 0,"should not persist id")}function checkLightJsonReading(e,t){var i=new THREE.ObjectLoader,n=i.parse(e);QUnit.assert.smartEqual(n,t,"Reconstruct Light from ObjectLoader")}function checkLightJsonRoundtrip(e){var t=e.toJSON();checkLightJsonWriting(e,t),checkLightJsonReading(t,e)}QUnit.assert.success=function(e){QUnit.assert.push(!0,void 0,void 0,e)},QUnit.assert.fail=function(e){QUnit.assert.push(!1,void 0,void 0,e)},QUnit.assert.numEqual=function(e,t,i){var n=Math.abs(e-t);i=i||e+" should be equal to "+t,QUnit.assert.push(n<.1,e,t,i)},QUnit.assert.equalKey=function(e,t,i){var n=e[i],r=t[i],o=n+" should be equal to "+r+' for key "'+i+'"';QUnit.assert.push(n==r,n,r,o)},QUnit.assert.smartEqual=function(e,t,i){var n=new SmartComparer,r=n.areEqual(e,t),o=n.getDiagnostic()||i;QUnit.assert.push(r,e,t,o)};