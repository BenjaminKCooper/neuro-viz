THREE.GLNode=function(e){this.uuid=THREE.Math.generateUUID(),this.allows={},this.requestUpdate=!1,this.type=e},THREE.GLNode.prototype.parse=function(e,t){t=t||{},e.parsing=!0;var r=e.material;this.build(e.addCache(t.cache,t.requires).addSlot(t.slot),"v4"),r.clearVertexNode(),r.clearFragmentNode(),e.removeCache().removeSlot(),e.parsing=!1},THREE.GLNode.prototype.parseAndBuildCode=function(e,t,r){return r=r||{},this.parse(e,r),this.buildCode(e,t,r)},THREE.GLNode.prototype.buildCode=function(e,t,r){r=r||{};var o=e.material,a={result:this.build(e.addCache(r.cache,r.requires).addSlot(r.slot),t)};return e.isShader("vertex")?a.code=o.clearVertexNode():a.code=o.clearFragmentNode(),e.removeCache().removeSlot(),a},THREE.GLNode.prototype.build=function(e,t,r){t=t||this.getType(e,t);var o=e.material,a=o.getDataNode(r||this.uuid);if(e.parsing&&this.appendDepsNode(e,a,t),this.allows[e.shader]===!1)throw new Error("Shader "+shader+" is not compatible with this node.");return this.requestUpdate&&o.requestUpdate.indexOf(this)===-1&&o.requestUpdate.push(this),this.generate(e,t,r)},THREE.GLNode.prototype.appendDepsNode=function(e,t,r){t.deps=(t.deps||0)+1;var o=e.getFormatLength(r);(o>(t.outputMax||0)||this.getType(e,r))&&(t.outputMax=o,t.output=r)},THREE.GLNode.prototype.getType=function(e,t){return"sampler2D"===t||"samplerCube"===t?t:this.type};